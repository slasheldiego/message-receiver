/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package messages.receiver;

import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;

import com.azure.messaging.eventhubs.EventHubClientBuilder;
import com.azure.messaging.eventhubs.EventProcessorClient;
import com.azure.messaging.eventhubs.EventProcessorClientBuilder;
import com.azure.messaging.eventhubs.checkpointstore.blob.BlobCheckpointStore;
import com.azure.messaging.eventhubs.models.ErrorContext;
import com.azure.messaging.eventhubs.models.EventContext;
import com.azure.storage.blob.BlobContainerAsyncClient;
import com.azure.storage.blob.BlobContainerClientBuilder;

import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.Consumer;

import java.util.concurrent.TimeUnit;

import messages.receiver.kafka.ConsumerCreator;
import messages.receiver.interfaces.IKafkaConstants;

public class App {

    private static final String EH_NAMESPACE_CONNECTION_STRING = "Endpoint=sb://beleventhubscope.servicebus.windows.net/;SharedAccessKeyName=RootManageSharedAccessKey;SharedAccessKey=2vWIt/DWSit0pyqCN23dK9ua/TJszYl9/XCQKcZfXXQ=";
    private static final String eventHubName = "beleventhub01";
    private static final String STORAGE_CONNECTION_STRING = "DefaultEndpointsProtocol=https;AccountName=externaladls;AccountKey=ex3Aub4/ASCifVpcxGGl+rWFYLxLgImWkOxOUPEIC6XAxstRpYnVVNFFMhtGkVAMbcJwHK1HwImaZlTL2zU8jQ==;EndpointSuffix=core.windows.net";
    private static final String STORAGE_CONTAINER_NAME = "stream";

    /*public static final Consumer<EventContext> PARTITION_PROCESSOR = eventContext -> {
        System.out.printf("Processing event from partition %s with sequence number %d with body: %s %n",
                eventContext.getPartitionContext().getPartitionId(), eventContext.getEventData().getSequenceNumber(),
                eventContext.getEventData().getBodyAsString());

        if (eventContext.getEventData().getSequenceNumber() % 10 == 0) {
            eventContext.updateCheckpoint();
        }
    };*/

    /*public static final Consumer<ErrorContext> ERROR_HANDLER = errorContext -> {
        System.out.printf("Error occurred in partition processor for partition %s, %s.%n",
                errorContext.getPartitionContext().getPartitionId(), errorContext.getThrowable());
    };*/

    public String getGreeting() {
        return "Hello world.";
    }

    public static void main(String[] args) throws InterruptedException {
        System.out.println(new App().getGreeting());

        /*
        // Create a blob container client that you use later to build an event processor
        // client to receive and process events
        BlobContainerAsyncClient blobContainerAsyncClient = new BlobContainerClientBuilder()
                .connectionString(STORAGE_CONNECTION_STRING).containerName(STORAGE_CONTAINER_NAME).buildAsyncClient();

        // Create a builder object that you will use later to build an event processor
        // client to receive and process events and errors.
        EventProcessorClientBuilder eventProcessorClientBuilder = new EventProcessorClientBuilder()
                .connectionString(EH_NAMESPACE_CONNECTION_STRING, eventHubName).consumerGroup("app-consumer01")
                // .consumerGroup(EventHubClientBuilder.DEFAULT_CONSUMER_GROUP_NAME)
                .processEvent(PARTITION_PROCESSOR).processError(ERROR_HANDLER)
                .checkpointStore(new BlobCheckpointStore(blobContainerAsyncClient));

        // Use the builder object to create an event processor client
        EventProcessorClient eventProcessorClient = eventProcessorClientBuilder.buildEventProcessorClient();

        System.out.println("Starting event processor");
        eventProcessorClient.start();

        System.out.println("Press enter to stop.");
        int inChar;
        try {
            inChar = System.in.read();
            System.out.print("You entered ");
            System.out.println(inChar);
        } catch (IOException e) {
            System.out.println("Error reading from user");
        }

        System.out.println("Stopping event processor");
        eventProcessorClient.stop();
        System.out.println("Event processor stopped.");

        System.out.println("Exiting process");*/
        //runConsumer();
        int i = 1;
        while (true){
            try{
                FileWriter write = new FileWriter("test.txt", true);
                PrintWriter print_write = new PrintWriter(write);

                print_write.printf("Dummy test: " + i + "\n");
                //System.out.println("Dummy test: " + i);
                i++;
                print_write.close();
                Thread.sleep(5000);
            } catch(IOException e){
                System.out.println(e);
            }
        }
    }

    static void runConsumer() {
        Consumer<Long, String> consumer = ConsumerCreator.createConsumer();

        int noMessageFound = 0;

        while (true) {
          ConsumerRecords<Long, String> consumerRecords = consumer.poll(1000);
          // 1000 is the time in milliseconds consumer will wait if no record is found at broker.
          if (consumerRecords.count() == 0) {
              noMessageFound++;
              if (noMessageFound > IKafkaConstants.MAX_NO_MESSAGE_FOUND_COUNT)
                // If no message found count is reached to threshold exit loop.  
                break;
              else
                  continue;
          }

          //print each record. 
          consumerRecords.forEach(record -> {
              System.out.println("Record Key " + record.key());
              System.out.println("Record value " + record.value());
              System.out.println("Record partition " + record.partition());
              System.out.println("Record offset " + record.offset());
           });

          // commits the offset of record to broker. 
           consumer.commitAsync();
        }
    consumer.close();
    }

}